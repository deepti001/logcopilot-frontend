import { VulnerabilityRecord, VulnerabilityDatabase, BuildScan, DetectionEvent } from '../types/vulnerability';
import { api } from "./api";

class VulnerabilityService {
  private db: VulnerabilityDatabase = {};
  private buildHistory: BuildScan[] = [];

  constructor() {
    this.loadFromStorage();
    // Initialize with fresh mock data if no data exists
    if (Object.keys(this.db).length === 0 && this.buildHistory.length === 0) {
      this.initializeMockData();
    }
  }

  /**
   * Process a new build scan and update vulnerability detection records
   */
  processBuildScan(scan: BuildScan, vulnerabilities: Omit<VulnerabilityRecord, 'firstDetected' | 'lastSeen' | 'detectionHistory'>[]): void {
    const now = scan.timestamp;
    
    // Add scan to history
    this.buildHistory.push(scan);
    
    // Process each vulnerability
    vulnerabilities.forEach(vuln => {
      const existing = this.db[vuln.id];
      
      const detectionEvent: DetectionEvent = {
        buildId: scan.buildId,
        environment: scan.environment,
        release: scan.release,
        timestamp: now,
        scanType: 'ci/cd', // Could be determined by context
        imageInfo: scan.imageInfo
      };

      if (existing) {
        // Update existing vulnerability
        existing.lastSeen = now;
        existing.detectionHistory.push(detectionEvent);
        // Update other fields that might have changed
        existing.component = vuln.component;
        existing.description = vuln.description;
        existing.aiRecommendation = vuln.aiRecommendation;
        existing.layer = vuln.layer;
      } else {
        // New vulnerability - first detection
        this.db[vuln.id] = {
          ...vuln,
          firstDetected: now,
          lastSeen: now,
          detectionHistory: [detectionEvent]
        };
      }
    });

    this.saveToStorage();
  }

  /**
   * Get vulnerabilities for a specific time period
   */
  getVulnerabilitiesForPeriod(environment: string, release: string, period: string): VulnerabilityRecord[] {
    const now = new Date();
    let startDate: Date;

    switch (period) {
      case 'latest':
        return this.getLastBuildVulnerabilities(environment, release);
      case '1-day':
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '1-week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '1-month':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        return [];
    }

    return Object.values(this.db)
      .filter(vuln => vuln && vuln.firstDetected && vuln.detectionHistory) // Ensure valid structure
      .filter(vuln => 
        vuln.firstDetected >= startDate &&
        vuln.detectionHistory.some(event => 
          event.environment === environment && 
          event.release === release
        )
      );
  }

  /**
   * Get vulnerabilities from the most recent build
   */
  getLastBuildVulnerabilities(environment: string, release: string): VulnerabilityRecord[] {
    // Find the most recent build for this environment/release
    const recentBuild = this.buildHistory
      .filter(build => build.environment === environment && build.release === release)
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];

    if (!recentBuild) return [];

    // Return vulnerabilities found in that build
    return recentBuild.vulnerabilities
      .map(cveId => this.db[cveId])
      .filter(Boolean) // Remove any undefined/null entries
      .filter(vuln => vuln.id && vuln.severity) // Ensure required fields exist
      .sort((a, b) => this.getSeverityWeight(b.severity) - this.getSeverityWeight(a.severity));
  }

  /**
   * Get formatted detection time for display
   */
  getDetectionTimeDisplay(vuln: VulnerabilityRecord, viewMode: string): string {
    if (!vuln) return 'Unknown';
    
    if (viewMode === 'latest') {
      // Return layer info for single build view
      return vuln.layer || 'Unknown layer';
    }
    
    // Return relative time for time-based views
    if (!vuln.firstDetected) return 'Unknown';
    return this.formatRelativeTime(vuln.firstDetected);
  }

  /**
   * Format build timestamp for display
   */
  formatBuildTime(buildInfo: BuildScan | null): string {
    if (!buildInfo || !buildInfo.timestamp) {
      return '2 hours ago'; // fallback
    }
    return this.formatRelativeTime(buildInfo.timestamp);
  }

  /**
   * Get build metadata for the most recent scan
   */
  getLastBuildInfo(environment: string, release: string): BuildScan | null {
    return this.buildHistory
      .filter(build => build.environment === environment && build.release === release)
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0] || null;
  }

  /**
   * Get statistics for dashboard
   */
  getVulnerabilityStats(environment: string, release: string, period: string) {
    const vulns = this.getVulnerabilitiesForPeriod(environment, release, period);
    
    return {
      total: vulns.length,
      critical: vulns.filter(v => v.severity === 'Critical').length,
      high: vulns.filter(v => v.severity === 'High').length,
      medium: vulns.filter(v => v.severity === 'Medium').length,
      low: vulns.filter(v => v.severity === 'Low').length,
      newInPeriod: this.getNewVulnerabilitiesCount(environment, release, period)
    };
  }

  private getNewVulnerabilitiesCount(environment: string, release: string, period: string): number {
    if (period === 'latest') return 0;
    
    const now = new Date();
    let startDate: Date;
    
    switch (period) {
      case '1-day':
        startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '1-week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '1-month':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        return 0;
    }

    return Object.values(this.db).filter(vuln => 
      vuln.firstDetected >= startDate &&
      vuln.detectionHistory.some(event => 
        event.environment === environment && 
        event.release === release
      )
    ).length;
  }

  private getSeverityWeight(severity: string): number {
    switch (severity) {
      case 'Critical': return 4;
      case 'High': return 3;
      case 'Medium': return 2;
      case 'Low': return 1;
      default: return 0;
    }
  }

  private formatRelativeTime(date: Date | string): string {
    if (!date) return 'Unknown';
    
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    if (isNaN(dateObj.getTime())) return 'Unknown';
    
    const now = new Date();
    const diffMs = now.getTime() - dateObj.getTime();
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffHours / 24);

    if (diffHours < 1) return 'Just now';
    if (diffHours < 24) return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
    if (diffDays < 7) return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
    return dateObj.toLocaleDateString();
  }

  private loadFromStorage(): void {
    try {
      const stored = localStorage.getItem('vulnerability-db');
      if (stored) {
        const parsed = JSON.parse(stored);
        this.db = parsed.db || {};
        this.buildHistory = (parsed.buildHistory || []).map((build: any) => ({
          ...build,
          timestamp: new Date(build.timestamp)
        }));
        
        // Convert date strings back to Date objects
        Object.values(this.db).forEach(vuln => {
          vuln.firstDetected = new Date(vuln.firstDetected);
          vuln.lastSeen = new Date(vuln.lastSeen);
          vuln.detectionHistory = vuln.detectionHistory.map(event => ({
            ...event,
            timestamp: new Date(event.timestamp)
          }));
        });
      }
    } catch (error) {
      console.error('Failed to load vulnerability database:', error);
    }
  }

  private saveToStorage(): void {
    try {
      const data = {
        db: this.db,
        buildHistory: this.buildHistory
      };
      localStorage.setItem('vulnerability-db', JSON.stringify(data));
    } catch (error) {
      console.error('Failed to save vulnerability database:', error);
    }
  }

  // Get build comparison data for "This build vs previous"
  getBuildComparison(environment: string, release: string): {
    newInBuild: number;
    resolvedSincePrevious: number;
    unchanged: number;
  } {
    const builds = this.buildHistory
      .filter(build => build.environment === environment && build.release === release)
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

    if (builds.length < 2) {
      return { newInBuild: 0, resolvedSincePrevious: 0, unchanged: 0 };
    }

    const currentBuild = builds[0];
    const previousBuild = builds[1];

    const currentVulns = new Set(currentBuild.vulnerabilities);
    const previousVulns = new Set(previousBuild.vulnerabilities);

    const newInBuild = currentBuild.vulnerabilities.filter(cve => !previousVulns.has(cve)).length;
    const resolvedSincePrevious = previousBuild.vulnerabilities.filter(cve => !currentVulns.has(cve)).length;
    const unchanged = currentBuild.vulnerabilities.filter(cve => previousVulns.has(cve)).length;

    return { newInBuild, resolvedSincePrevious, unchanged };
  }

  // Get filtered vulnerabilities based on criteria
  getFilteredVulnerabilities(
    vulnerabilities: VulnerabilityRecord[],
    filters: {
      release?: string[];
      environment?: string[];
      repo?: string[];
      image?: string[];
      severity?: string[];
    }
  ): VulnerabilityRecord[] {
    return vulnerabilities.filter(vuln => {
      // Filter by severity
      if (filters.severity && filters.severity.length > 0) {
        if (!filters.severity.includes(vuln.severity)) return false;
      }

      // Filter by repo
      if (filters.repo && filters.repo.length > 0) {
        if (!vuln.repo || !filters.repo.includes(vuln.repo)) return false;
      }

      // Filter by image
      if (filters.image && filters.image.length > 0) {
        if (!vuln.image || !filters.image.includes(vuln.image)) return false;
      }

      // Filter by environment and release through detection history
      if (filters.environment && filters.environment.length > 0) {
        const hasMatchingEnv = vuln.detectionHistory.some(event => 
          filters.environment!.includes(event.environment)
        );
        if (!hasMatchingEnv) return false;
      }

      if (filters.release && filters.release.length > 0) {
        const hasMatchingRelease = vuln.detectionHistory.some(event => 
          filters.release!.includes(event.release)
        );
        if (!hasMatchingRelease) return false;
      }

      return true;
    });
  }

  // Get available filter options from current data
  getFilterOptions(): {
    releases: string[];
    environments: string[];
    repos: string[];
    images: string[];
    severities: string[];
  } {
    const releases = new Set<string>();
    const environments = new Set<string>();
    const repos = new Set<string>();
    const images = new Set<string>();
    const severities = new Set<string>();

    // Collect from build history
    this.buildHistory.forEach(build => {
      releases.add(build.release);
      environments.add(build.environment);
    });

    // Collect from vulnerabilities
    Object.values(this.db).forEach(vuln => {
      severities.add(vuln.severity);
      if (vuln.repo) repos.add(vuln.repo);
      if (vuln.image) images.add(vuln.image);
    });

    return {
      releases: Array.from(releases).sort(),
      environments: Array.from(environments).sort(),
      repos: Array.from(repos).sort(),
      images: Array.from(images).sort(),
      severities: ['Critical', 'High', 'Medium', 'Low']
    };
  }

  // Method to initialize with mock data for development
  initializeMockData(): void {
    // Clear existing data for fresh initialization
    this.db = {};
    this.buildHistory = [];

    const now = new Date();

    // Create vulnerabilities with specific discovery times to match time period filters
    const vulnerabilityDataWithTiming = [
      // Recent vulnerabilities (last 24 hours) - for "1 Day" filter
      {
        id: "CVE-2024-1234",
        severity: "Critical" as const,
        component: "node:18-alpine",
        description: "Remote code execution vulnerability in Node.js runtime",
        layer: "Layer 3 (node runtime)",
        aiRecommendation: "Upgrade to node:20-alpine immediately. This critical vulnerability allows remote code execution.",
        packageInfo: { name: "node", installedVersion: "18.17.0", fixedVersion: "20.0.0" },
        repo: "backend-api", image: "prod-app:latest", cvssScore: 9.8,
        discoveryHoursAgo: 2 // Discovered 2 hours ago
      },
      {
        id: "CVE-2024-9012",
        severity: "Medium" as const,
        component: "react:18.2.0",
        description: "Cross-site scripting vulnerability in React DOM",
        layer: "Layer 7 (npm dependencies)",
        aiRecommendation: "Update to React 18.3+ and ensure proper input sanitization in all user-facing components.",
        packageInfo: { name: "react", installedVersion: "18.2.0", fixedVersion: "18.3.0" },
        repo: "frontend-web", image: "prod-app:latest", cvssScore: 6.1,
        discoveryHoursAgo: 18 // Discovered 18 hours ago
      },
      
      // Week-old vulnerabilities (last 7 days) - for "1 Week" filter
      {
        id: "CVE-2024-5678",
        severity: "High" as const,
        component: "nginx:1.21",
        description: "Buffer overflow in HTTP module can lead to denial of service",
        layer: "Layer 5 (nginx package)",
        aiRecommendation: "Update to nginx:1.25+ and review server configurations for security best practices.",
        packageInfo: { name: "nginx", installedVersion: "1.21.6", fixedVersion: "1.25.0" },
        repo: "frontend-web", image: "nginx:1.21", cvssScore: 7.5,
        discoveryHoursAgo: 48 // Discovered 2 days ago
      },
      {
        id: "CVE-2024-3456",
        severity: "High" as const,
        component: "postgresql:14",
        description: "SQL injection potential in PostgreSQL query parser",
        layer: "Layer 4 (postgres base)",
        aiRecommendation: "Upgrade to PostgreSQL 15+ and use parameterized queries exclusively for all database operations.",
        packageInfo: { name: "postgresql", installedVersion: "14.8", fixedVersion: "15.0" },
        repo: "backend-api", image: "postgres:14", cvssScore: 8.8,
        discoveryHoursAgo: 96 // Discovered 4 days ago
      },
      {
        id: "CVE-2024-2345",
        severity: "High" as const,
        component: "express:4.17.1",
        description: "Path traversal vulnerability in Express.js static file serving",
        layer: "Layer 8 (application dependencies)",
        aiRecommendation: "Update Express.js to 4.19+ and validate all file path inputs to prevent directory traversal.",
        packageInfo: { name: "express", installedVersion: "4.17.1", fixedVersion: "4.19.0" },
        repo: "backend-api", image: "prod-app:latest", cvssScore: 8.1,
        discoveryHoursAgo: 120 // Discovered 5 days ago
      },
      
      // Month-old vulnerabilities (last 30 days) - for "1 Month" filter
      {
        id: "CVE-2024-8901",
        severity: "Critical" as const,
        component: "openssl:1.1.1",
        description: "Heap buffer overflow in OpenSSL certificate parsing",
        layer: "Layer 2 (system libraries)",
        aiRecommendation: "Immediately upgrade to OpenSSL 3.0+ to prevent potential remote code execution.",
        packageInfo: { name: "openssl", installedVersion: "1.1.1f", fixedVersion: "3.0.0" },
        repo: "backend-api", image: "ubuntu:22.04", cvssScore: 9.9,
        discoveryHoursAgo: 240 // Discovered 10 days ago
      },
      {
        id: "CVE-2024-7890",
        severity: "Low" as const,
        component: "curl:7.81.0",
        description: "Information disclosure in curl library",
        layer: "Layer 2 (system libraries)",
        aiRecommendation: "Update curl to version 8.0+ to resolve information disclosure vulnerability.",
        packageInfo: { name: "curl", installedVersion: "7.81.0", fixedVersion: "8.0.0" },
        repo: "backend-api", image: "ubuntu:22.04", cvssScore: 3.7,
        discoveryHoursAgo: 360 // Discovered 15 days ago
      },
      {
        id: "CVE-2024-6789",
        severity: "Medium" as const,
        component: "lodash:4.17.20",
        description: "Prototype pollution vulnerability in lodash utility functions",
        layer: "Layer 8 (application dependencies)",
        aiRecommendation: "Upgrade lodash to 4.17.21+ and review code for potential prototype pollution vectors.",
        packageInfo: { name: "lodash", installedVersion: "4.17.20", fixedVersion: "4.17.21" },
        repo: "frontend-web", image: "prod-app:latest", cvssScore: 5.6,
        discoveryHoursAgo: 480 // Discovered 20 days ago
      }
    ];

    // Create builds and vulnerabilities with proper timing
    const buildConfigs = [
      // Most recent build (2 hours ago) - has recent vulnerabilities
      {
        buildId: 'build-12350',
        hoursAgo: 2,
        vulnerabilities: ['CVE-2024-1234', 'CVE-2024-9012', 'CVE-2024-5678', 'CVE-2024-3456']
      },
      // Previous build (1 day ago) - for comparison
      {
        buildId: 'build-12349',
        hoursAgo: 24,
        vulnerabilities: ['CVE-2024-5678', 'CVE-2024-3456', 'CVE-2024-7890']
      },
      // Older builds for month view
      {
        buildId: 'build-12348',
        hoursAgo: 120, // 5 days ago
        vulnerabilities: ['CVE-2024-2345', 'CVE-2024-7890', 'CVE-2024-6789']
      },
      {
        buildId: 'build-12347',
        hoursAgo: 240, // 10 days ago
        vulnerabilities: ['CVE-2024-8901', 'CVE-2024-7890', 'CVE-2024-6789']
      }
    ];

    // Process each build and its vulnerabilities
    buildConfigs.forEach(config => {
      const buildTime = new Date(now.getTime() - (config.hoursAgo * 60 * 60 * 1000));
      
      const buildVulns = config.vulnerabilities.map(cveId => {
        const baseVuln = vulnerabilityDataWithTiming.find(v => v.id === cveId);
        if (!baseVuln) return null;
        
        return {
          id: baseVuln.id,
          severity: baseVuln.severity,
          component: baseVuln.component,
          description: baseVuln.description,
          layer: baseVuln.layer,
          aiRecommendation: baseVuln.aiRecommendation,
          packageInfo: baseVuln.packageInfo,
          repo: baseVuln.repo,
          image: baseVuln.image,
          cvssScore: baseVuln.cvssScore
        };
      }).filter(Boolean);

      const build: BuildScan = {
        buildId: config.buildId,
        environment: 'prod',
        release: 'v2.1.4',
        timestamp: buildTime,
        imageInfo: {
          name: 'prod-app',
          tag: config.buildId === 'build-12350' ? 'latest' : `v2.1.4-${config.buildId.split('-')[1]}`,
          baseImage: 'node:18-alpine'
        },
        vulnerabilities: config.vulnerabilities
      };

      // Manually create vulnerability records with correct timing
      buildVulns.forEach(vuln => {
        const baseVuln = vulnerabilityDataWithTiming.find(v => v.id === vuln.id);
        const firstDetectedTime = new Date(now.getTime() - (baseVuln.discoveryHoursAgo * 60 * 60 * 1000));
        
        if (!this.db[vuln.id]) {
          this.db[vuln.id] = {
            ...vuln,
            firstDetected: firstDetectedTime,
            lastSeen: buildTime,
            detectionHistory: [{
              buildId: config.buildId,
              environment: 'prod',
              release: 'v2.1.4',
              timestamp: buildTime,
              scanType: 'ci/cd' as const,
              imageInfo: build.imageInfo
            }]
          };
        } else {
          // Update existing record
          this.db[vuln.id].lastSeen = buildTime;
          this.db[vuln.id].detectionHistory.push({
            buildId: config.buildId,
            environment: 'prod',
            release: 'v2.1.4',
            timestamp: buildTime,
            scanType: 'ci/cd' as const,
            imageInfo: build.imageInfo
          });
        }
      });

      this.buildHistory.push(build);
    });

    // Sort build history by timestamp (newest first)
    this.buildHistory.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    
    this.saveToStorage();
  }

  // Helper to select vulnerabilities for a build based on timeline
  private selectVulnerabilitiesForBuild(pool: any[], count: number, daysAgo: number): any[] {
    // Earlier builds have different vulnerability sets
    // More recent builds tend to have newer vulnerabilities discovered
    const shuffled = [...pool].sort(() => Math.random() - 0.5);
    
    if (daysAgo > 20) {
      // Older builds: mostly older vulnerabilities
      return shuffled.slice(2, 2 + count);
    } else if (daysAgo > 7) {
      // Medium timeframe: mix of old and medium-age vulnerabilities
      return shuffled.slice(1, 1 + count);
    } else if (daysAgo > 1) {
      // Recent builds: include some newer vulnerabilities
      return shuffled.slice(0, count);
    } else {
      // Latest builds: current vulnerability set
      return shuffled.slice(0, Math.min(count, 4));
    }
  }

  // Reset and regenerate all mock data (useful for development)
  resetMockData(): void {
    localStorage.removeItem('vulnerability-db');
    this.db = {};
    this.buildHistory = [];
    this.initializeMockData();
  }
}

export const vulnerabilityService = new VulnerabilityService();

export type SuggestionRequest = {
  name: string;
  severity: string;
  package_name?: string;
  package_version?: string;
  description?: string;
};

export async function getRemediationSuggestion(payload: SuggestionRequest): Promise<string> {
  const res = await api.post<{ suggestion: string }>("/vulnerabilities/suggest", payload);
  return (res.data?.suggestion || "").trim();
}